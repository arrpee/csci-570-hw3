570 Project Group: Raaj Patil, Raajitha Rajkumar

Insights/Observations:

In this program, we used dynamic programming for our basic algorithm. We have a matrix that gets updated with the values while traversing through. In the memory plot for this, we can see that the program takes up a lot of space.

In our efficient algorithm, we focus on using O(m+n) memory and computing the alignment in linear space. We do this by creating a size |m|*2 matrix and reusing memory within the columns of the matrix. We can discard old columns because we only need the memory of the column before to compute the alignment, only needing two columns at a time.

We then compute the split node through the minimum cost of forward and backward sequence alignment, and then split the problem into parts, repeating the algorithm and solving subproblems in the time proportional to its area.

You can see in the memory plot that the efficient algorithm takes up much less space than the basic algorithm, by reusing memory as it divide-and-conquers the solution, but at the cost of more computation.

From our results, we can see that as the problem size got bigger, the memory used stayed under 20000 kb for the efficient algorithm for all problem sizes, while it increased to over 100000 kb for the basic algorithm.

We can attest this to the basic algorithm not reusing any memory while traversing through the matrix, while the efficient algorithm implemented the space efficient sequence alignment algorithms.

However, when looking at the CPU time taken as the problem size increased, the basic algorithm actually took lesser CPU time than the efficient algorithm, but the difference was only in the value of the slope. We can see that there is still an upwards trend for both CPU times for both algorithms.

When we compare the problem size 2e6 again, the time taken for the basic solution is about 0.75 s, while the time for the efficient solution is 1.75 s.

The time has about twice the difference, while the space between the 2 solutions had almost 6 times the difference for that specific problem size. We can see that the tradeoff here deems the efficient solution better. For bigger problem spaces, using less O(m+n) memory over O(mn) memory is very useful.


Individual contributions:

The basic algorithm for this project was fully implemented by Raaj P. For the efficient algorithm, Raaj P. and Raajitha R. worked on the forward space efficient, backward space efficient, and recursive functions together. The efficient solution strategies were researched by both of us. Raaj P. handled the plots/outputs while Raajitha R. handled the summary.
